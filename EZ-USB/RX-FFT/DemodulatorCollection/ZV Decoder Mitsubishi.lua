
                                 
-- 1000001010 1111100000 0111101010 0110011001 0000110110 1000011101 0100100011 1101111100 1000000011
-- 1000001010 1111100000 0111101010 0110011001 0000010011 0000010000 1100101100 1110111010 1100101111
-- 1000001010 1111100000 0111101010 0110011001 0000011111 0000011100 1101111001 1100110001 1001011010
-- 1000001010 1111100000 0111101010 0110011001 0000001011 0001110001 0101111111 1110011000 1111110010
-- 1000001010 1111100000 0111101010 0110011001 0000000100 1100010000 0111000010 1010010111 1110000110
-- 1000001010 1111100000 0111101010 0110011000 0000000011 0000001011 1110111111 1111100110 1110110101
                                                                                        
-- ========== ========== ========== =========6 ====704063 47=7760470 0=40603033 =634360004 =304004060   Score for being same in all frames                                 
-- [--------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- --------]^   Parity (even) match:  Bit 89 over 89 bits before.
                                                                                        
-- xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx                                                                     XORMatch:  Bit 0 Bit 10 Bit 10 over 10 bits. 


-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010110010110011001101010100110010101010110010101010101010101011010101001100110011001101001010110011
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010110010110011001101010100110010101010110010101010101010101011010101001100110011001101001010110011
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010110010110011001101010100110010101010110010101010101010101011010101001100110011001101001010110011
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010110010110011001101010100110010101010110010101010101010101011010101001100110011001101001010110011
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010110010101101010100110100110010110100110101010010110011001010110011001100101011001011010011010101
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010110010101101010100110100110010110100110101010010110011001010110011001100101011001011010011010101
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010110010101101010100110100110010110100110101010010110011001010110011001100101011001011010011010101
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010110010101101010100110100110010110100110101010010110011001010110011001100101011001011010011010101
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010110010101011001101010101010010110011010010110101001010110010101010110101010011010011001010110011
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010110010101011001101010101010010110011010010110101001010110010101010110101010011010011001010110011
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010110010101011001101010101010010110011010010110101001010110010101010110101010011010011001010110011
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010110010101011001101010101010010110011010010110101001010110010101010110101010011010011001010110011
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101101010101001100110100110011001101010100101011010010110100110010101011010011001011001100101101
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101101010101001100110100110011001101010100101011010010110100110010101011010011001011001100101101
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101101010101001100110100110011001101010100101011010010110100110010101011010011001011001100101101
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101101010101001100110100110011001101010100101011010010110100110010101011010011001011001100101101
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101101010011001100110100110011001101010100110011001100101101010101001101001011010010110010101101
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101101010011001100110100110011001101010100110011001100101101010101001101001011010010110010101101
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101101010011001100110100110011001101010100110011001100101101010101001101001011010010110010101101
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101101010011001100110100110011001101010100110011001100101101010101001101001011010010110010101101
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101101001101010101010101010010101011010101010011001010110100101011001011010011001011001101010011
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101101001101010101010101010010101011010101010011001010110100101011001011010011001011001101010011
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101101001101010101010101010010101011010101010011001010110100101011001011010011001011001101010011
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101101001101010101010101010010101011010101010011001010110100101011001011010011001011001101010011
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101101001011001100110100110010101011010100110101001011010100101011010100101011001100101100110011
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101101001011001100110100110010101011010100110101001011010100101011010100101011001100101100110011
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101101001011001100110100110010101011010100110101001011010100101011010100101011001100101100110011
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101101001011001100110100110010101011010100110101001011010100101011010100101011001100101100110011
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101100110101001010110101010100101101010100110101001011010100110100110101010011001100110010101101
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101100110101001010110101010100101101010100110101001011010100110100110101010011001100110010101101
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101100110101001010110101010100101101010100110101001011010100110100110101010011001100110010101101
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101100110101001010110101010100101101010100110101001011010100110100110101010011001100110010101101
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101100110011001010110101010101001101010100101011001100101100110010101101010011010100101101010101
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101100110011001010110101010101001101010100101011001100101100110010101101010011010100101101010101
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101100110011001010110101010101001101010100101011001100101100110010101101010011010100101101010101
-- 0000000010101010101010101010101010101001010101010110100101100110011010101010101001100110100101101010011010100110101001010101100110011001010110101010101001101010100101011001100101100110010101101010011010100101101010101
        -- [---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]   BMC from 8 to end

-- globals for PSK demodulation
BaudRate = 4000;   -- this is before biphase decoding
MinDbDistance = 20;
UseFastAtan2 = true;       -- will use a inaccurate but fast atan2() function

-- globals for decoding
DumpType = 2; -- 1 = dump raw bit stream from PSK, 2 = remove header/trailer and dump BMC decoded data, 3 = decode message
ShortHeaderSequence = "0000000000000001";
FullHeaderSequence = "0000000";
FooterSequence = "111111111111";

-- internal state variables
BitsProcessed = 0;
BitStream = "";
BMCActive = false;

DecodedBitStream = "";

CommandTypes = 
{
	[9] = "Lock",
	[10] = "Unlock",
	[11] = "Rear lid",
	[15] = "Lock finish?",
}

function string:split2(sep)
  local t, ll
  t={}
  ll=0
  if(#self == 1) then return {self} end
    while true do
      l=string.find(self,sep,ll,true) -- find the next sep in the string
      if l~=nil then -- if "not not" found then..
        table.insert(t, string.sub(self,ll,l-1)) -- Save it in our array.
        ll=l+sep:len() -- save just after where we found it for searching next time.
      else
        table.insert(t, string.sub(self,ll)) -- Save what's left in our array.
        break -- Break at end, as it should be, according to the lua manual.
      end
    end
  return t
end

function string:split(sep)
        local sep, fields = sep or ":", {}
        local pattern = string.format("([^%s]+)", sep)
        self:gsub(pattern, function(c) fields[#fields+1] = c end)
        return fields
end

-- called when script is loaded
function Init()
	print("-------------------------");
	print("  Audi ZV  Decoder v1.0  ");
	print("         by g3gg0.de     ");
	print("-------------------------");
	
	-- set up default values
	PSK = new("PSKDemodulator");
	PSK.BaudRate = BaudRate;	
	PSK.MinDbDistance = MinDbDistance;	
	PSK.UseFastAtan2 = UseFastAtan2;
	PSK.SamplingRate = SamplingRate;
	SetDemodulator(PSK);
	
	-- create a new biphase decoder and set ourself as its bitsink
	BMC = new("BiphaseDecoder");
    BMC.Verbose= false;
	BMC.BitSink = this();
end

-- called whenever sampling rate has changed
function SamplingRateChanged()
end

-- called when carrier was detected.
function TransmissionStart()
	BitStream = "";
	BitsProcessed = 0;
end

-- called when the demodulator lost its signal. 
function TransmissionEnd()

	if(DumpType == 1) then
		print("Raw bit data: "..BitStream);
	else
		if(BitsProcessed>2) then
			-- now skip first and last bit and clock that into BMC
			BMCActive = true;
            
            local frames = BitStream:split2(FullHeaderSequence);
            
            print("Decoding packet with "..#frames.." fields");
            
			for frame = 1, #frames do            
                DecodedBitStream = "";
                
                local data = frames[frame];
                local footer = data:sub(data:len() - (FooterSequence:len() - 1));
                
                if(footer == FooterSequence) then
                    -- cut trailing bits
                    data = data:sub(1, data:len() - (FooterSequence:len() - 1));
                    
                    print("Raw bit data fed into BMC: "..data);
                    -- synchronize BMC
                    BMC.Synchronize(BMC, data:sub(1, 1) == '0');
                    
                    for pos = 1, frames[frame]:len() do
                        BMC.ClockBit(BMC, data:sub(pos, pos) == '1');
                    end
                    
                    
                    if(DumpType == 2) then
                        print("BMC Decoded: "..DecodedBitStream);
                    else
                        ProcessBitFrame(DecodedBitStream);
                    end
                else
                    print("footer mismatch: "..footer);
                end
            end
            BMCActive = false;
		end
	end
end

-- called when preceding bitdecoder (like BMC decoder) thinks it is in sync again.
-- this tells us that it seems to have lost its synchronization and the data we received before might be crap.
function Resynchronized()
	if(not BMCActive) then	
		BitStream = "";
		BitsProcessed = 0;
	else
		DecodedBitStream = "";
	end
end

function Desynchronized()
	if(not BMCActive) then	
		BitStream = "";
		BitsProcessed = 0;
	else
        if(DumpType == 2) then
            print("BMC Decoded: "..DecodedBitStream);
        else
            ProcessBitFrame(DecodedBitStream);
        end    
		DecodedBitStream = "";
	end
end

-- whenever there is a new data bit, its getting clocked using this function. the data bit is already decoded by the BMC decoder.
function ClockBit(state)

	if(not BMCActive) then	
		-- clock a new bit. simply append to the BitStream buffer
		if(state) then
			BitStream = BitStream.."1";
		else
			BitStream = BitStream.."0";
		end
		
		BitsProcessed = BitsProcessed + 1;	
	else
		if(state) then
			DecodedBitStream = DecodedBitStream.."0";
		else
			DecodedBitStream = DecodedBitStream.."1";
		end
	end
end



function ProcessBitFrame(frame)

	if(frame:len() == 234) then
		if(frame:sub(1,FullHeaderSequence:len()) == FullHeaderSequence) then
			-- split the frame into 8 bit words
			local payload = frame:sub(FullHeaderSequence:len() + 1) ;
			local frameData = SplitFrame(payload, 8);
			local command = "unknown";
			
			if(CommandTypes[BinToInt(frameData[1])] ~= nil) then
				command = CommandTypes[BinToInt(frameData[1])];
			end
			
			print("FullFrame");
			print("    Command:   "..string.format("0x%02X ", BinToInt(frameData[1])).." ("..command..")");
			print("    Key:       "..string.format("0x%02X%02X%02X%02X%02X%02X%02X", BinToInt(frameData[2]), BinToInt(frameData[3]), BinToInt(frameData[4]), BinToInt(frameData[5]), BinToInt(frameData[6]), BinToInt(frameData[7]), BinToInt(frameData[8])));
			print("    Separator: "..string.format("0x%02X ", BinToInt(frameData[9])));
			print("    Car ID:    "..string.format("0x%02X ", BinToInt(frameData[10])));
			print("    Chk:       "..string.format("0x%02X%02X", BinToInt(frameData[11]), BinToInt(frameData[12])));
		else
			print("FullFrame, but invalid Header");
		end
	elseif(frame:len() == 24) then
		if(frame:sub(1,ShortHeaderSequence:len()) == ShortHeaderSequence) then
			-- split the frame into 8 bit words
			local payload = frame:sub(ShortHeaderSequence:len() + 1) ;
			local frameData = SplitFrame(payload, 8);
			local command = "unknown";
			
			if(CommandTypes[BinToInt(frameData[1])] ~= nil) then
				command = CommandTypes[BinToInt(frameData[1])];
			end
			print("ShortFrame:    "..string.format("0x%02X ", BinToInt(frameData[1])).." ("..command..")");
		else
			print("ShortFrame, but invalid Header");
		end	
	else
		print("Invalid frame length ("..frame:len()..")");
		print("    Frame: "..frame);
	end
	
end

function SplitFrame(frame, wordLength)
	local pos = 1;
	local words = {};
	
	while ( frame:len() > 0 ) do
		words[pos] = frame:sub(1,wordLength);
		pos = pos + 1;
		frame = frame:sub(wordLength + 1);
	end
	
	return words;
end

function BinToInt(binary)
	local value = 0;
	
	while ( binary:len() > 0 ) do
		value = value * 2;
		
		if ( binary:sub(1,1) == "1") then
			value = value + 1;
		end
		
		binary = binary:sub(2);
	end
	
	return value;
end


